const std = import "@stdlib"
const input = import "./input"

pub const TITLE = "Day 12: Christmas Tree Farm";

pub struct Shape { tile: bool[9], count: int }
pub struct Region {
	width: int, height: int,
	shape_count: int[6],
}


pub fn solve_a() {
	let inp = input::parse_input();

	// for let i = 0; i < 6; i+=1 {
	// 	print_shape(&inp.shapes[i]);
	// 	std::putchar('\n');
	// }
	// for let i = 0; i < inp.region_count; i+=1 {
	// 	print_region(&inp.regions[i]);
	// 	std::putchar('\n');
	// }
	// std::printf("region_c: %d\n", inp.region_count);
	// std::printf("solve_a\n");

	let min_possible = 0;
	let max_possible = 0;
	for let i = 0; i < inp.region_count; i+=1 {
		if !quick_is_impossible(&inp.regions[i], inp.shapes) {
			max_possible += 1;
		}
		if quick_trivial(&inp.regions[i]) {
			min_possible += 1;
		}
	}
	// You are very very evil.
	std::printf("min: %d max: %d\n", min_possible, max_possible);
}


fn quick_trivial(region: *Region): bool {
	let sum = 0;
	for let j = 0; j < 6; j+=1 {
		sum += region.shape_count[j] * 9;
	}
	let area = region.width * region.height;
	return area >= sum;
}


fn quick_is_impossible(region: *Region, shapes: *Shape): bool {
	let sum = 0;
	for let j = 0; j < 6; j+=1 {
		sum += region.shape_count[j] * shapes[j].count;
	}
	let area = region.width * region.height;
	return area < sum;
}


pub fn solve_b() { std::printf("***** Merry Christmas! *****\n"); }

fn print_region(region: *Region) {
	std::printf("%dx%d:", region.width, region.height);
	for let i = 0; i < 6; i+=1 {
		std::printf(" %d", region.shape_count[i]);
	}
}


fn print_shape(shape: *Shape) {
	std::printf("count: %d\n", shape.count);
	for let i = 0; i < 9; i+=1 {
		if shape.tile[i] {
			std::putchar('#');
		} else {
			std::putchar('.');
		}
		if (i + 1) % 3 == 0 {
			std::putchar('\n');
		}
	}
}

