const std = import "@stdlib"


pub fn line_count(s: str): int {
	return count_char(s, '\n') + 1;
}

pub fn count_char(s: str, c: char): int {
	let offset = 0;
	let count = 0;
	while s[offset] != '\0' {
		if s[offset] == c {
			count += 1;
		}
		offset += 1;
	}
	return count;
}

pub fn count_until(s: str, pred: fn(str): bool): int {
	let offset = 0;
	while s[offset] != '\0' && !pred(&s[offset]) {
		offset += 1;
	}
	return offset;
}

pub fn is_whitespace(s: str): bool {
	match *s {
		' ' | '\t' | '\r' | '\0' | '\n' => return true;
		_ => return false;
	}
}

// For more context patterns
pub fn count_pred(s: str, pred: fn(str): bool): int {
	let offset = 0;
	let count = 0;
	while s[offset] != '\0' {
		if pred(&s[offset]) { count += 1; }
		offset += 1;
	}
	return count;
}


pub fn debug_char(c: char) {
	match c {
		'\n' => std::printf("\\n\n"),
		'\t' => std::printf("\\t"),
		'\r' => std::printf("\\r"),
		'\0' => std::printf("\\0"),
		_ => std::putchar(c),
	}
}

pub fn debug(s: str) {
	let offset = 0;
	loop {
		match s[offset] {
			'\n' => std::printf("\\n\n"),
			'\t' => std::printf("\\t"),
			'\r' => std::printf("\\r"),
			'\0' => break;
			_ => std::putchar(s[offset]),
		}
		offset += 1;
	}
}
